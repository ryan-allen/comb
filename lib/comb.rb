require_relative 'comb/version'
require 'time'

class Comb
  def self.assemble(path_to_modules)
    new(path_to_modules).assemble
  end

private

  def initialize(path_to_modules)
    # instance vars are just global vars in sheeps clothing
    @path_to_modules = path_to_modules
    @output = [] 
    @timestamp = Time.new.utc.iso8601 # baaaaaaaaaaa
  end

public
  
  def assemble
    mark_start_of_output
    append_require_snippet
    for_each_js_module do |name, code|
      append_to_output(name, code)
    end
    mark_end_of_output
    return_output
  end

private

  def mark_start_of_output
    @output << "// generated by comb on #{@timestamp}"
  end

  def append_require_snippet
    @output << (<<-eos
var require = function(module) {
  return require.registry[module]()
}
require.registry = {}
require.register = function(module, code) {
  require.registry[module] = code
}
    eos
    ).chomp
  end

  def for_each_js_module
    Dir.glob(@path_to_modules + '/**/*.js').each do |path| 
      # get the module 'name' by removing the path and the extension
      name = path.gsub(@path_to_modules, '').gsub(/^\//, '').gsub(/\.js$/, '')
      code = File.open(path) { |f| f.read }
      yield name, code
    end
  end

  def append_to_output(name, code)
      @output << (<<-eos
require.register('#{name}', function() {
#{indent_code(code)}
})
      eos
      ).chomp
  end

  def indent_code(code)
    code.split("\n").collect { |line| "  #{line}" }.join("\n")
  end

  def mark_end_of_output
    @output << "// end of comb output at #{@timestamp}"
  end

  def return_output
    @output.join("\n")
  end
end
